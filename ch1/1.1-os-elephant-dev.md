# 1 龙芯启动，向内核迈进

### 前言

本教程用于学习龙芯架构，并进行编程实践。所说的龙芯架构包含了 loongarch 架构，以及龙芯硬件与系统之间的规范。讲述方式是将 os-elephant-dev 操作系统移植到龙芯架构上，在移植的过程中逐渐深入理解龙芯架构。选用的操作系统是比较容易上手的操作系统，其使用C语言完成开发，并有配套的书籍详细描述细节。所以移植过程中涉及到架构相关的内容会展开进行讲述，系统相关的内容会大致进行描述，在系统相关代码不影响理解的情况下深入理解龙芯架构。

本教程在 ubuntu20.04 系统下，选用 QEMU 模拟龙芯硬件环境进行开发，模拟的CPU型号为 3A5000，桥片为 7A1000。提到 3A5000 和 7A1000 可能会有点迷惑，所以先介绍一下 3A5000 和 7A1000，这样能够先大致了解龙芯。在介绍完 3A5000 和 7A1000 后再简单介绍一下 os-elephant-dev 操作系统，并在 bochs 模拟器中运行 x86 架构的 os-elephant-dev。

### 2 os-elephant-dev 简介

os-elephant-dev 是《操作系统-真相还原》配套的操作系统，该书详细描述了如何实现该操作系统。该系统实现了中断、内存管理、线程、用户进程、磁盘驱动、文件系统和一些系统调用，包含了操作系统中的各个模块。接下来运行一下 os-elephant-dev 操作系统，**本节的作用是建立项目的目录基本结构，并且对系统有个大致认识**。

x86 架构的 os-elephant-dev 能运行起来就行了，为了尽量不修改系统相关代码，也为了不影响本教程的进度，所以使用与原书相同的环境运行，即 bochs 运行 x86 架构的 os-elephant-dev 操作系统。建议仔细阅读本节后续内容，与本教程的环境配置相同，尽量不在配置上花费太多精力。下面开始配置 x86 架构 os-elephant-dev 的运行环境。

下载 os-loongson 项目，其中包含 os-elephant-dev 操作系统，下载完成后，切换到本节对应的分支，然后进入 os-loongson 中：

```bash
git clone https://github.com/huloves/os-loongson
cd os-loongson/
os-loongson$ git checkout ch1-2
```

> 当前工作目录：os-loongson/，上面命令行中出现的 os-loongson$ 表示工作目录，注意仅复制工作目录后的命令部分。后面出现类似的内容皆为当前工作目录。

进入到项目工作目录后，开始安装 bochs，首先安装 bochs 可能依赖的库文件：

```bash
os-loongson$ sudo apt install build-essential
os-loongson$ sudo apt-get install libghc-x11-dev
os-loongson$ sudo apt-get install xorg-dev
```

下载 bochs，并解压到 os-loongson 目录中，然后在 os-loongson 目录中创建 bochs/ 目录，该 bochs 目录将作为安装 bochs 时的目标目录，安装的文件会安装在该目录中。创建 bochs/ 目录完成之后使用 ls 命令查看当前工作目录中的内容：

<pre class="language-bash"><code class="lang-bash"><strong>os-loongson$ wget https://udomain.dl.sourceforge.net/project/bochs/bochs/2.6.8/bochs-2.6.8.tar.gz
</strong>os-loongson$ tar -xvf bochs-2.6.8.tar.gz
os-loongson$ mkdir bochs
os-loongson$ ls
bochs-2.6.8.tar.gz  bochs-2.6.8  bochs  os-elephant-dev README.md
</code></pre>

解压完成后，进入 bochs 源码目录，进行配置、编译、安装。安装的目标目录在配置的时候由 --prefix 参数指定，**注意 prefix 中写成自己创建的 bochs 目录绝对路径，此处仅给出示例**。编译过程中可能会出现未安装的依赖库文件，一般安装后即可。

```bash
os-loongson$ cd bochs-2.6.8.tar.gz
os-loongson/bochs$ ./configure --prefix=os-loongson/bochs --enable-debugger --enable-disasm --enable-iodebug --enable-x86-debugger --with-x --with-x11 LDFLAGS='-pthread'
os-loongson/bochs$ make
os-loongson/bochs$ make install
```

到这里 bochs 就安装完成了，之后进入安装的目标目录中，即 `os-loongson/bochs` 中配置运行 x86 架构 os-elephant-dev 操作系统所需要的配置文件。需要的配置文件这里下面都会列出来，依然为了不影响本教程的进度，配置文件将会直接给出可以使用的链接，点击文件名即可下载。

* [hd60M.img](https://github.com/Qiubomm-OS/toolchains/releases/download/v0.1/hd60M.img) - 未分区虚拟磁盘，编译出的 x86 架构 os-elephant-dev 内核会写录入该文件
* [hd80M.img](https://github.com/Qiubomm-OS/toolchains/releases/download/v0.1/hd80M.img) - 已分区，用于文件系统
* [bochsrc.disk](https://github.com/Qiubomm-OS/toolchains/releases/download/v0.1/bochsrc.disk) - 该文件下载下来后注意其内容中，有关路径的部分替换为自己环境下的路径

下载完成后将下载的文件放到 `os-loongson/bochs` 目录下。此时在 `os-loongson/bochs` 目录下使用 ls 命令查看文件，显示如下：

```bash
os-loongson/bochs$ ls
bin  bochsrc.disk  hd60M.img  hd80M.img  share
```

到这里 x86 架构 os-elephant-dev 的运行环境就配置完成了。下面开始编译 x86 架构 os-elephant-dev 代码并运行。

首先进入 `os-loongson/os-elephant-dev/` 目录中。找到 makefile 文件中 hd 目标的内容，并将其后面的命令修改为自己环境下的路径。这里给出示例：

```makefile
hd:
	dd if=$(BUILD_DIR)/mbr.bin of=/home/huloves/repositories/os-loongson/bochs/hd60M.img bs=512 count=1  conv=notrunc
	dd if=$(BUILD_DIR)/loader.bin of=/home/huloves/repositories/os-loongson/bochs/hd60M.img bs=512 count=4 seek=2 conv=notrunc
	dd if=$(BUILD_DIR)/kernel.bin of=/home/huloves/repositories/os-loongson/bochs/hd60M.img bs=512 count=200 seek=9 conv=notrunc
```

然后在 `os-loongson/os-elephant-dev/` 目录执行下述命令编译链接，并写入到虚拟磁盘中：

```bash
os-loongson/os-elephant-dev$ make all
```

进入 os-loongson/bochs 目录，执行下述命令运行 x86 架构的 os-elephant-dev 操作系统：

```bash
os-loongson/bochs$ ./bin/bochs -f bochsrc.disk
```

执行成功的话会显示如下界面：

<figure><img src="../.gitbook/assets/2041692809453_的副本.pic.jpg" alt="" width="489"><figcaption><p>图 1.2.1 bochs 运行界面展示 1</p></figcaption></figure>

到这里按下回车默认执行第六个选项，显示如下图所示的界面，并伴随一个如下图所示的黑框：

<figure><img src="../.gitbook/assets/WX20230824-005338.png" alt="" width="560"><figcaption><p>图 1.2.2 bochs 运行界面展示 2</p></figcaption></figure>

<figure><img src="../.gitbook/assets/WX20230824-005503.png" alt="" width="479"><figcaption><p>图 1.2.3 bochs 运行界面展示 3</p></figcaption></figure>

然后输入c，并按下回车开始运行，运行截图如下所示：

<figure><img src="../.gitbook/assets/WX20230824-014542.png" alt="" width="537"><figcaption><p>图 1.2.4 bochs 运行界面展示 4</p></figcaption></figure>

<figure><img src="../.gitbook/assets/WX20230824-014724.png" alt="" width="537"><figcaption><p>图 1.2.5 bochs 运行界面展示 5</p></figcaption></figure>

### 3 配置龙芯工作环境

#### 配置qemu运行环境

在os-loongson中创建qemu目录，其中放置需要使用的QEMU。

> QEMU是一个通用的开源机器模拟器和虚拟器。[QEMU Main Documentation](https://www.qemu.org/docs/master/)

开始搭建loongarh架构的qemu运行环境。

下载[qemu-system-loongarch64](https://github.com/Qiubomm-OS/toolchains/releases/download/v0.1/qemu-system-loongarch64)、[loongarch\_bios\_0310\_debug.bin](https://github.com/Qiubomm-OS/toolchains/releases/download/v0.1/loongarch\_bios\_0310\_debug.bin)和[efi-virtio.rom](https://github.com/Qiubomm-OS/toolchains/releases/download/v0.1/efi-virtio.rom)到os-loongson/qemu中。

在os-loongson/qemu.目录下使用下述命令试运行：

```bash
cd qemu
./qemu-system-loongarch64 -m 4G -smp 1 -bios ./loongarch_bios_0310_debug.bin -vga none -nographic
```

> efi-virtio.rom - qemu需要使用的rom file。
>
> loongarch\_bios\_0310\_debug.bin. loongarch架构UEFI bios二进制程序。

试运行截图：

![image-20230819195642027](../Users/huloves/Pictures/image-20230819195642027.png)

#### 下载编译工具链

在os-loongson中创建toolchains目录，其中放置需要用到的工具链。

下载工具链包 [loongarch64-clfs-6.3-cross-tools-gcc-full.tar.xz](https://github.com/Qiubomm-OS/toolchains/releases/download/v0.1/loongarch64-clfs-6.3-cross-tools-gcc-full.tar.xz) 到os-loongson下，并解压到os-loongson/toolchains中，解压命令如下：

```bash
tar -xvf loongarch64-clfs-6.3-cross-tools-gcc-full.tar.xz -C toolchains
```

### 3 龙芯启动部分程序，向内核迈进

从计算机的启动到执行C语言程序大致流程为：1.计算机上电 `->` 2.运行ROM程序（BIOS、UEFI） `->` 3.从ROM程序接管计算机控制，进行初步设置 `->` 4.运行C语言程序。这其中内核编程人员从第3步开始需要编写程序，且这部分代码基本上为直接操作寄存器进行设置，所以一般使用汇编代码编写。当对计算机进行内核所需的初始化之后，跳转到C语言程序部分开始执行后续内容。后续内容中一般只有少部分代码需要直接操作寄存器，所以后续直接操作寄存器的内容一般使用内敛汇编完成。

> 如果后续内容中存在需要大量操作寄存器的部分，也会直接编写汇编程序。例如例外和中断处理、上下文切换。

本章龙芯启动部分程序的内容为：从ROM程序开始接管计算机控制，进行初步设置，然后跳转至C语言程序。C语言程序中使用串口输出功能，输出`hello os-loongson`。
